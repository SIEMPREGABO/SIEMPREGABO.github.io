<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optimización de Sistemas de Archivos</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&family=Open+Sans:wght@400;600&display=swap" rel="stylesheet">
    <script type="text/javascript" src="jquery.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"
        integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
        <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/popper.js@1.12.9/dist/umd/popper.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/js/bootstrap.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --accent-color: #e74c3c;
            --light-color: #ecf0f1;
            --dark-color: #2c3e50;
            --text-color: #333;
            --text-light: #7f8c8d;
        }

        body {
            font-family: 'Open Sans', sans-serif;
            color: var(--text-color);
            line-height: 1.6;
        }

        h1,
        h2,
        h3,
        h4,
        h5,
        h6,
        .navbar-brand,
        .nav-link,
        .boton-disp {
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
        }

        .navbar-personalizado {
            background-color: var(--primary-color);
            padding: 15px 0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .disposicion {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            width: 100%;
        }

        .disposicion-logos {
            display: flex;
            justify-content: space-between;
            width: 100%;
            padding: 0 20px;
            margin-bottom: 20px;
        }

        .disposicion-logos div {
            display: flex;
            align-items: center;
        }

        .disposicion-logos img {
            max-height: 60px;
        }

        .navbar-brand {
            color: white !important;
            font-size: 1.5rem;
            margin-right: 30px;
        }

        .nav-link {
            color: rgba(255, 255, 255, 0.8) !important;
            padding: 8px 15px !important;
            transition: all 0.3s ease;
        }

        .nav-link:hover {
            color: white !important;
            transform: translateY(-2px);
        }

        .dropdown-menu {
            border: none;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
        }

        .dropdown-item {
            padding: 8px 20px;
            transition: all 0.2s;
        }

        .dropdown-item:hover {
            background-color: var(--secondary-color);
            color: white !important;
        }

        .container {
            max-width: 1200px;
            padding: 20px;
        }

        .presentacion {
            background-color: var(--secondary-color);
            color: white;
            padding: 40px;
            border-radius: 10px;
            margin: 20px 0;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
        }

        .presentacion:hover {
            transform: translateY(-5px);
        }

        .boton-disp {
            width: 100%;
            margin: 10px 0;
            padding: 15px 20px;
            border: none;
            background-color: var(--primary-color);
            color: white;
            font-size: 1.1rem;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        }

        .boton-disp:hover {
            background-color: var(--dark-color);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .boton-disp i {
            transition: transform 0.3s ease;
        }

        .boton-disp.collapsed i {
            transform: rotate(-90deg);
        }

        #div_1,
        #div_2,
        #div_3,
        #div_4,
        #div_5 {
            padding: 25px;
            background-color: white;
            border-radius: 0 0 8px 8px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
            border-left: 4px solid var(--secondary-color);
        }

        footer {
            background-color: var(--primary-color);
            color: white;
            padding: 50px 0 0;
            margin-top: 50px;
        }

        footer h5 {
            color: white;
            margin-bottom: 20px;
            font-weight: 700;
        }

        footer .nav-link {
            color: rgba(255, 255, 255, 0.7) !important;
            padding: 5px 0 !important;
        }

        footer .nav-link:hover {
            color: white !important;
            padding-left: 10px !important;
        }

        .border-top {
            border-color: rgba(255, 255, 255, 0.1) !important;
        }

        .social-icons a {
            color: white;
            font-size: 1.5rem;
            margin: 0 10px;
            transition: all 0.3s;
        }

        .social-icons a:hover {
            color: var(--secondary-color);
            transform: translateY(-3px);
        }

        .color-text {
            color: white;
        }

        .renglones{
            display: flex;
            flex-direction: column;
        }

        .margin-padding{
            margin: 0;
            padding: 0;
        }

        @media (max-width: 768px) {
            .disposicion {
                flex-direction: column;
            }

            .navbar-brand {
                margin-bottom: 15px;
            }

            .presentacion {
                padding: 20px;
            }
        }
    
        h1, h2, h3 {
            color: #2c3e50;
        }
        table {
            width: 100%;
            border-collapse: collapse; 
            margin: 20px 0;
        }
        table, th, td {
            border: 1px solid #ddd;
        }
        th, td {
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        figure {
            margin: 20px 0;
            text-align: center;
        }
        figcaption {
            font-style: italic;
            margin-top: 10px;
        }
        .highlight {
            background-color: #f8f9fa;
            padding: 15px;
            border-left: 4px solid #4285f4;
            margin: 20px 0;
        }

        .paginacion {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 30px 0;
        }
        
        .btn-paginacion {
            padding: 10px 25px;
            background-color: #2c3e50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            text-decoration: none;
        }
        
        .btn-paginacion:hover {
            background-color: #3498db;
            text-decoration: none;
        }
        
        .btn-paginacion:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
            text-decoration: none;
        }
    </style>
</head>
<body>

    <div id="navbar-container"></div>

    <div class="container">
        <div class="presentacion">
            <h2>4.5 Optimización del Sistema de Archivos</h2>
            <p>Maximizando rendimiento y eficiencia en la gestión de datos</p>
        </div>

        <div class="section">
            <p>Los sistemas de archivos son la columna vertebral de la gestión de datos en sistemas operativos, responsables de organizar, almacenar y recuperar información de manera eficiente. La optimización de estos sistemas busca maximizar el rendimiento, reducir la latencia y garantizar la integridad de los datos, especialmente en entornos con altas demandas de acceso (ej. servidores, bases de datos). Factores como la fragmentación, el tamaño de bloques, el journaling y las políticas de almacenamiento en caché influyen directamente en su eficacia. Esta investigación explora las facetas clave para ajustar el rendimiento de un sistema de archivos, respaldada por referencias académicas y técnicas.</p>
        </div>

        <div class="section" id="ajuste-rendimiento">
            <h3>Facetas en el Ajuste de Rendimiento del Sistema de Archivos</h3>
            
            <div class="subsection">
                <div class="quote">
                    1. Almacenamiento en Caché (Silberschatz et al., 2018, p. 533).
                </div>
                
                <h4>Definición:</h4>
                <p>Uso de memoria RAM para almacenar datos accedidos frecuentemente, reduciendo las operaciones de lectura/escritura en disco.</p>
                
                <h4>Beneficios:</h4>
                <ul class="feature-list">
                    <li>Disminuye la latencia en accesos repetidos.</li>
                    <li>Optimiza el uso de recursos del sistema.</li>
                </ul>
                
                <h4>Ejemplo:</h4>
                <ul class="feature-list">
                    <li>Linux: Utiliza el Page Cache para almacenar datos de archivos en memoria.</li>
                    <li>Windows: Emplea el Cache Manager integrado en el kernel.</li>
                </ul>
            </div>

            <div class="subsection">
                <div class="quote">
                    2. Ajuste del Tamaño de Bloques (Tanenbaum y Woodhull. 2006, p. 215).
                </div>
                
                <h4>Definición:</h4>
                <p>Configuración del tamaño de los bloques de almacenamiento para equilibrar espacio y rendimiento. Bloques grandes reducen la fragmentación, mientras que bloques pequeños minimizan el espacio desperdiciado.</p>
                
                <h4>Beneficios:</h4>
                <ul class="feature-list">
                    <li>Mejora la eficiencia en el almacenamiento de archivos pequeños o grandes.</li>
                </ul>
                
                <h4>Ejemplo:</h4>
                <ul class="feature-list">
                    <li>ext4: Permite bloques de 1 KB a 64 KB.</li>
                    <li>NTFS: Usa clústeres de 4 KB por defecto.</li>
                </ul>
            </div>

            <div class="subsection">
                <div class="quote">
                    3. Reducción de la Fragmentación (Carrier, 2005, p. 89).
                </div>
                
                <h4>Definición:</h4>
                <p>Técnicas para evitar que los archivos se almacenen en bloques no contiguos, lo que ralentiza el acceso.</p>
                
                <h4>Estrategias:</h4>
                <ul class="feature-list">
                    <li>Asignación contigua: Usada en sistemas como NTFS.</li>
                    <li>Algoritmos de colocación: Como el best-fit o worst-fit.</li>
                </ul>
            </div>

            <div class="subsection">
                <div class="quote">
                    4. Optimización del Journaling (Linux Kernel Documentation, s. f.).
                </div>
                
                <h4>Definición:</h4>
                <p>Configuración del diario (journal) para registrar operaciones críticas sin penalizar el rendimiento.</p>
                
                <h4>Modos:</h4>
                <ul class="feature-list">
                    <li>Write-ahead logging: Solo registra metadatos (ej. ext3).</li>
                    <li>Data journaling: Registra metadatos y datos (mayor seguridad, menor velocidad).</li>
                </ul>
            </div>

            <div class="subsection">
                <div class="quote">
                    5. Gestión de Metadatos Eficiente (Silberschatz et al.,2018, p. 487).
                </div>
                
                <h4>Definición:</h4>
                <p>Organización optimizada de metadatos (permisos, fechas, ubicación) para acelerar búsquedas.</p>
                
                <h4>Ejemplo:</h4>
                <ul class="feature-list">
                    <li>ZFS: Almacena metadatos en árboles B+ para accesos rápidos.</li>
                </ul>
            </div>

            <div class="subsection">
                <div class="quote">
                    6. Uso de RAID y SSDs (Patterson, Gibson & Katz, 1988, p. 113).
                </div>
                
                <h4>Definición:</h4>
                <p>Combinación de discos (RAID) o uso de unidades de estado sólido (SSDs) para mejorar velocidad y redundancia.</p>
                
                <h4>Beneficios:</h4>
                <ul class="feature-list">
                    <li>RAID 0: Aumenta la velocidad mediante striping.</li>
                    <li>SSDs: Reducen la latencia en operaciones aleatorias.</li>
                </ul>
            </div>

            <p>La optimización de sistemas de archivos requiere equilibrar velocidad, integridad y uso de recursos. Estrategias como el ajuste de bloques, el almacenamiento en caché y la elección adecuada de journaling son críticas en entornos empresariales. Sistemas modernos como ZFS y ext4 ejemplifican cómo estas técnicas se integran para manejar cargas de trabajo intensivas, aunque su configuración debe adaptarse a cada caso de uso.</p>
        </div>

        <div class="section" id="recuperacion-archivos">
            <h3>4.5.1 Recuperación de archivos de un dispositivo</h3>
            
            <h4>Introducción</h4>
            <p>La recuperación de archivos es un proceso crítico para restaurar datos perdidos o eliminados de dispositivos de almacenamiento (discos duros, SSDs, memorias USB, etc.). Las causas comunes incluyen:</p>
            
            <ul class="feature-list">
                <li>Eliminación accidental (por usuarios o aplicaciones).</li>
                <li>Fallos de hardware (sectores dañados, discos corruptos).</li>
                <li>Ataques de malware (ransomware, virus).</li>
                <li>Errores del sistema de archivos (corrupción de metadatos).</li>
            </ul>
            
            <p>Esta investigación explora los métodos de recuperación, estudios sobre la estructura de archivos/carpetas y técnicas de búsqueda eficiente, respaldados por referencias académicas y técnicas.</p>

            <div class="subsection">
                <div class="quote">
                    Métodos de Recuperación de Archivos (Carrier, 2005, pp. 150-165).
                </div>
                
                <h4>1. Recuperación mediante Software</h4>
                <p><strong>Definición:</strong> Uso de herramientas como Recuva, TestDisk o PhotoRec para escanear el dispositivo y reconstruir archivos eliminados.</p>
                
                <h5>Funcionamiento:</h5>
                <ul class="feature-list">
                    <li>Análisis de metadatos: Busca entradas en tablas como la Master File Table (MFT) en NTFS o inodos en ext4.</li>
                    <li>Búsqueda de firmas de archivos (file carving): Identifica datos basándose en cabeceras únicas (ej. FF D8 FF para JPEG)</li>
                </ul>
                
                <h5>2. Recuperación Forense (Casey, 2011, pp 210-225).</h5>
                <p><strong>Definición:</strong> Técnicas avanzadas usadas en investigaciones legales o corporativas para extraer datos incluso de dispositivos dañados.</p>
                
                <h5>Herramientas:</h5>
                <ul class="feature-list">
                    <li>EnCase: Analiza sectores ocultos y particiones eliminadas.</li>
                    <li>FTK Imager: Crea imágenes forenses del disco para evitar modificaciones.</li>
                </ul>
                
                <h5>3. Recuperación Hardware (Jones, Bejtlich & Rose, 2006, pp. 95-110).</h5>
                <p><strong>Definición:</strong> Intervención física en dispositivos con fallos mecánicos (ej. cabezales de disco dañados).</p>
                
                <h5>Proceso:</h5>
                <ul class="feature-list">
                    <li>Reparación en sala limpia: Reemplazo de componentes en entornos libres de polvo.</li>
                    <li>Extracción directa de chips: Usado en SSDs o memorias NAND.</li>
                </ul>
            </div>

            <div class="subsection">
                <div class="quote">
                    Estudios de Información de Archivos y Carpetas (Silberschatz et al.,2018, pp. 480-485).
                </div>
                
                <h4>1. Estructura de Archivos</h4>
                <ul class="feature-list">
                    <li>Metadatos: Permisos, fechas, tamaño (almacenados en inodos o MFT).</li>
                    <li>Datos: Contenido real del archivo (almacenado en bloques o clústeres).</li>
                </ul>
                
                <h4>2. Comportamiento de Eliminación (Microsoft, s. f., sección "File Deletion").</h4>
                <ul class="feature-list">
                    <li>Marcado de espacio libre: Los sistemas de archivos marcan los bloques como disponibles, pero los datos persisten hasta ser sobrescritos.</li>
                    <li>Ejemplo: En NTFS, la entrada en la MFT se marca como no utilizada.</li>
                </ul>
            </div>

            <div class="subsection">
                <div class="quote">
                    Técnicas de Búsqueda para Recuperación (Carrier, 2005, p. 170).
                </div>
                
                <h4>1. Búsqueda por Firmas</h4>
                <p><strong>Definición:</strong> Identificación de archivos basada en patrones hexadecimales únicos (ej. PDF inicia con 25 50 44 46).</p>
                
                <h4>Herramientas:</h4>
                <ul class="feature-list">
                    <li>PhotoRec: Recupera más de 500 formatos de archivo.</li>
                </ul>
                
                <h4>2. Análisis de Metadatos (Linux Kernel Documentation, s. f., Ext.4).</h4>
                <p><strong>Definición:</strong> Reconstrucción de la estructura de directorios mediante registros de metadatos no sobrescritos.</p>
                
                <h5>Ejemplo:</h5>
                <ul class="feature-list">
                    <li>En ext4, los inodos eliminados pueden contener rutas originales.</li>
                </ul>
            </div>

            <p>En conclusión, la recuperación de archivos depende de factores como el sistema de archivos, el tiempo transcurrido desde la eliminación y el tipo de daño. Métodos como el file carving y el análisis forense son efectivos si los datos no han sido sobrescritos. Estudiar la estructura de archivos y utilizar herramientas especializadas maximiza las posibilidades de éxito, especialmente en casos críticos (ej. datos empresariales o evidencia legal).</p>
        </div>

        <div class="section" id="consistencia-sistemas">
            <h3>4.5.2 Consistencia de sistemas de archivos</h3>
            
            <p>Los sistemas de archivos distribuyen datos en múltiples nodos para garantizar disponibilidad y escalabilidad, pero esto introduce desafíos en la coherencia de los datos. Dos modelos destacados son la consistencia fuerte y la consistencia eventual, cada uno con beneficios y limitaciones específicas.</p>

            <div class="subsection">
                <h4>1. Consistencia Fuerte (Viewnext, s. f., LinkedIn, s. f.).</h4>
                
                <h5>Definición</h5>
                <p>Garantiza que todas las réplicas de un dato reflejen la última actualización de forma inmediata. Si un usuario lee un dato, siempre obtendrá la versión más reciente, independientemente del nodo consultado.</p>
                
                <h5>Mecanismos de Implementación</h5>
                <ul class="feature-list">
                    <li>Transacciones ACID: Atomicidad, Consistencia, Aislamiento y Durabilidad (ej. bases de datos relacionales).</li>
                    <li>Protocolos de consenso: Como Two-Phase Commit (2PC) o Paxos, que sincronizan nodos antes de confirmar operaciones.</li>
                </ul>
                
                <h5>Beneficios</h5>
                <ul class="feature-list">
                    <li>Integridad garantizada: Ideal para sistemas críticos (ej. transacciones bancarias), donde la precisión es prioritaria.</li>
                    <li>Evita conflictos: Elimina lecturas obsoletas o incoherencias temporales.</li>
                </ul>
                
                <h5>Limitaciones</h5>
                <ul class="feature-list">
                    <li>Alta latencia: La sincronización entre nodos ralentiza las operaciones.</li>
                    <li>Escalabilidad reducida: La coordinación estricta limita el crecimiento en sistemas distribuidos.</li>
                </ul>
                
                <h5>Ejemplo:</h5>
                <p>Google Spanner utiliza relojes atómicos para mantener coherencia fuerte global.</p>
            </div>

            <div class="subsection">
                <h4>2. Consistencia Eventual (LinkedIn, s. f.).</h4>
                
                <h5>Definición</h5>
                <p>Permite divergencias temporales entre réplicas, asegurando que converjan a un estado coherente tras un período sin actualizaciones. Prioriza disponibilidad y escalabilidad sobre la coherencia inmediata.</p>
                
                <h5>Mecanismos de Implementación</h5>
                <ul class="feature-list">
                    <li>Replicación asincrónica: Las actualizaciones se propagan en segundo plano.</li>
                    <li>Técnicas de resolución de conflictos: Como CRDTs (tipos de datos replicados sin conflictos) o algoritmos de votación.</li>
                </ul>
                
                <h5>Beneficios</h5>
                <ul class="feature-list">
                    <li>Alta disponibilidad: Los nodos responden incluso en fallos de red o particiones.</li>
                    <li>Escalabilidad horizontal: Admite grandes volúmenes de datos y usuarios sin degradación.</li>
                </ul>
                
                <h5>Limitaciones</h5>
                <ul class="feature-list">
                    <li>Incoherencias temporales: Los usuarios pueden ver datos desactualizados.</li>
                    <li>Complejidad en resolución de conflictos: Requiere lógica adicional para manejar versiones divergentes.</li>
                </ul>
                
                <h5>Ejemplo:</h5>
                <p>Amazon DynamoDB usa last-write-wins para resolver conflictos en réplicas.</p>
            </div>

            <table>
                <caption>Tabla 3. Comparación y Contextos de Uso (Slideshare, 2022).</caption>
                <thead>
                    <tr>
                        <th>Aspecto</th>
                        <th>Consistencia Fuerte</th>
                        <th>Consistencia Eventual</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Prioridad</td>
                        <td>Precisión (ej. finanzas, salud)</td>
                        <td>Disponibilidad (ej. redes sociales, IoT)</td>
                    </tr>
                    <tr>
                        <td>Latencia</td>
                        <td>Alta</td>
                        <td>Baja</td>
                    </tr>
                    <tr>
                        <td>Escalabilidad</td>
                        <td>Limitada</td>
                        <td>Alta</td>
                    </tr>
                    <tr>
                        <td>Complejidad</td>
                        <td>Protocolos rígidos (ej. 2PC)</td>
                        <td>Técnicas flexibles (ej. CRDTs)</td>
                    </tr>
                </tbody>
            </table>
            
            <h4>Elección según Casos de Uso:</h4>
            <ul class="feature-list">
                <li>Consistencia fuerte: Transacciones financieras, sistemas de reservas.</li>
                <li>Consistencia eventual: Registro de logs, preferencias de usuario en aplicaciones web.</li>
            </ul>

            <h3>4. Técnicas para Mitigar Limitaciones (LinkedIn, s. f.).</h3>
            
            <h5>Patrones híbridos:</h5>
            <ul class="feature-list">
                <li>SAGAs: Coordinan transacciones largas mediante compensaciones en caso de fallos (ej. e-commerce).</li>
                <li>CQRS (Segregación de Responsabilidades de Consulta/Comando): Separa lecturas y escrituras para optimizar rendimiento.</li>
            </ul>
            
            <h5>Modelos de datos especializados:</h5>
            <ul class="feature-list">
                <li>CRDTs: Permiten fusión automática de datos sin conflictos (ej. editores colaborativos).</li>
            </ul>

            <p>La elección entre consistencia fuerte y eventual depende de los requisitos de precisión, disponibilidad y escalabilidad del sistema. Mientras la consistencia fuerte asegura integridad absoluta, su rigidez limita aplicaciones distribuidas a gran escala. Por otro lado, la consistencia eventual ofrece flexibilidad y rendimiento, pero requiere manejar incoherencias temporales. El uso de patrones híbridos y modelos de datos avanzados permite equilibrar estas propiedades, adaptándose a contextos como microservicios o Big Data.</p>
        </div>

        <div class="section" id="rendimiento-aix">
            <h3>4.5.3 Rendimiento en AIX</h3>
            
            <p>La configuración de los diferentes tipos de sistemas de archivos en AIX® influye considerablemente en el rendimiento general del sistema y, una vez instalado, resulta complicado modificarla. AIX® (Advanced Interactive eXecutive) es un sistema operativo Unix desarrollado por IBM, ampliamente utilizado en entornos empresariales y servidores de alto rendimiento. La configuración de sus sistemas de archivos impacta directamente en la eficiencia de operaciones de E/S, la integridad de datos y la escalabilidad.</p>

            <div class="subsection">
                <h4>1. Sistemas de Archivos en AIX</h4>
                
                <h5>a) Journaled File System (JFS)</h5>
                <p><strong>Definición:</strong> Sistema de archivos con journaling introducido en AIX 3.1. Registra cambios en un diario (journal) para garantizar consistencia tras fallos.</p>
                
                <h6>Características clave:</h6>
                <ul class="feature-list">
                    <li>Tamaño máximo de archivo: 64 GB.</li>
                    <li>Bloques de 4 KB a 128 KB.</li>
                    <li>Journaling de metadatos.</li>
                </ul>
                
                <h6>Configuración de rendimiento:</h6>
                <ul class="feature-list">
                    <li>Tamaño del journal: Un journal más grande reduce la frecuencia de escrituras (IBM, 2001, p. 45).</li>
                    <li>Asignación de bloques: Bloques grandes mejoran el rendimiento en archivos voluminosos (Smit, 2010, p. 89).</li>
                </ul>
                
                <div class="quote">
                    Referencia: IBM. (2001). AIX 5L Performance Tools Handbook (p. 45). IBM Redbooks.
                </div>
                
                <h5>b) Enhanced Journaled File System (JFS2)</h5>
                <p><strong>Definición:</strong> Evolución de JFS con soporte para archivos y volúmenes más grandes (introducido en AIX 5.2).</p>
                
                <h6>Características clave:</h6>
                <ul class="feature-list">
                    <li>Tamaño máximo de archivo: 1 PB.</li>
                    <li>Bloques de 512 bytes a 16 MB.</li>
                    <li>Journaling opcional de datos (modo "data=ordered").</li>
                </ul>
                
                <h6>Configuración de rendimiento:</h6>
                <ul class="feature-list">
                    <li>Modos de journaling:
                        <ul>
                            <li>data=writeback: Mejora velocidad al journalizar solo metadatos (IBM, 2007, p. 12).</li>
                            <li>data=journal: Mayor integridad, pero penaliza rendimiento.</li>
                        </ul>
                    </li>
                    <li>Fragmentación dinámica: Uso de extents para reducir fragmentación (Smit, 2010, p. 102).</li>
                </ul>
                
                <div class="quote">
                    Referencia: IBM. (2007). AIX 6 Advanced Technical Guide (p. 12). IBM Redbooks.
                </div>
                
                <h5>c) IBM Spectrum Scale (GPFS)</h5>
                <p><strong>Definición:</strong> Sistema de archivos paralelo y distribuido diseñado para Big Data y HPC.</p>
                
                <h6>Características clave:</h6>
                <ul class="feature-list">
                    <li>Escalabilidad horizontal: Sopeta petabytes de datos en clusters.</li>
                    <li>Replicación sincrónica/asincrónica.</li>
                    <li>Caché distribuida.</li>
                </ul>
                
                <h6>Configuración de rendimiento:</h6>
                <ul class="feature-list">
                    <li>Tamaño de bloque: 16 MB recomendado para cargas de trabajo intensivas (IBM, 2020, p. 7).</li>
                    <li>Políticas de almacenamiento: Tiering automático entre SSD y HDD.</li>
                    <li>Balanceo de carga: Distribución de datos en múltiples nodos (Henson, 2015, p. 34).</li>
                </ul>
                
                <div class="quote">
                    Referencia: Henson, V. (2015). GPFS Essentials. IBM DeveloperWorks (p. 34).
                </div>
            </div>

            <table>
                <caption>Tabla 4. Comparativa de Rendimiento</caption>
                <thead>
                    <tr>
                        <th>Parámetro</th>
                        <th>JFS</th>
                        <th>JFS2</th>
                        <th>GPFS</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Tamaño máximo</td>
                        <td>64 GB</td>
                        <td>1 PB</td>
                        <td>Exabytes</td>
                    </tr>
                    <tr>
                        <td>Acceso concurrente</td>
                        <td>Limitado</td>
                        <td>Moderado</td>
                        <td>Alto (clusters)</td>
                    </tr>
                    <tr>
                        <td>Latencia</td>
                        <td>Alta en datos=journal</td>
                        <td>Media</td>
                        <td>Baja</td>
                    </tr>
                    <tr>
                        <td>Caso de uso</td>
                        <td>Entornos legacy</td>
                        <td>Servidores empresariales</td>
                        <td>Big Data/HPC</td>
                    </tr>
                </tbody>
            </table>

            <div class="subsection">
                <h3>3. Estrategias de Optimización</h3>
                
                <h5>a) Ajuste de Journaling</h5>
                <ul class="feature-list">
                    <li>JFS/JFS2: Usar data=writeback para cargas de escritura intensivas (IBM, 2007, p. 15).</li>
                    <li>GPFS: Desactivar journaling en nodos de solo lectura (Henson, 2015, p. 40).</li>
                </ul>
                
                <h5>b) Tamaño de Bloques</h5>
                <ul class="feature-list">
                    <li>JFS2: Bloques de 16 MB para bases de datos (Smit, 2010, p. 105).</li>
                    <li>GPFS: Bloques de 16 MB para archivos científicos (IBM, 2020, p. 9).</li>
                </ul>
                
                <h5>c) Caché y Prefetching</h5>
                <ul class="feature-list">
                    <li>AIX LVM: Aumentar caché de LV para reducir accesos a disco (IBM, 2001, p. 50).</li>
                    <li>GPFS: Habilitar prefetching agresivo en cargas secuenciales (Henson, 2015, p. 38).</li>
                </ul>
            </div>
        </div>

        <div class="paginacion">
            <a href="Cuestionario4_4.html" class="btn-paginacion">Anterior</a>
            <a href="Cuestionario4_5.html" class="btn-paginacion">Siguiente</a>
        </div>
    </div>

    <div id="footer-container"></div>

    
</body>

<script>
    $(document).ready(function () {
        fetch('navbar.html')
            .then(response => response.text())
            .then(data => {
                document.getElementById('navbar-container').innerHTML = data;
                initNavbarScripts(); // Si necesitas inicializar scripts del navbar
            });

        fetch('footer.html')
            .then(response => response.text())
            .then(data => {
                document.getElementById('footer-container').innerHTML = data;
            });
    });
</script>

</html>